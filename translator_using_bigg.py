#!/user/bin/env python3

"""
Author: Gustavo Tamasco
Contact: tamascogustavo@gmail.com

"""

# import statements
from bioservices import BiGG
import os
from multiprocessing import Pool
import pickle
from collections import ChainMap
from bioservices.kegg import KEGG
from contextlib import redirect_stdout
from sys import argv

#functions and classes
def help_menu():
	print("""
		usage: python3 translator_using_bigg.py <BiGG organism name using _> [-h]

		Perform pathway annotation in the cytoscape file generated by chimera

		positional arguments:
		  INPUT                 Input (string with the organism name).
		  						- e.g: "p_putida" or "e_coli"
		                   

		optional arguments:
		  -h, --help            		show this help message and exit
		""")

def control(argument):
	try:
		if argument == "--help" or argument == "-h":
			help_menu()
		else:
			'''
			Setting the variable
			'''
			compounds_metadata = {}
			dirpath = os.getcwd()
			

			'''
			Generating info to build the dictionary of metabolites
			'''
			paths, dirs, filenames = list_files(dirpath)
			target = str([x for x in dirs if "psamm" in x])
			target_path = get_target_file(target, dirpath)
			with open(target_path) as compounds_info:
			    compounds_data = parse_compounds(compounds_info)

			'''
			Translation module : translate Bigg ids to kegg ids
			'''
			translator_dict_file = check_translation_need(compounds_data)

			with open(translator_dict_file, "rb") as handle:
				translator_dict = pickle.load(handle)
			
			
			all_kegg_ids = [x for x in translator_dict.values() if x.startswith("C0")]
			all_unique_kegg_ids = list(dict.fromkeys(all_kegg_ids))
			path_info = check_cyto_build(all_unique_kegg_ids)
			
			
			with open(path_info, "rb") as pth_handle:
				path_info_dict = pickle.load(pth_handle)

			
			'''
			Translate citoscape files

			'''
			graph_dir = str([x for x in dirs if "psamm" in x])[2:-2]
			graph_path = f"{dirpath}/{graph_dir}"
			os.chdir(graph_path)
			edge_file = str([x for x in list_files(graph_path)[2] if "reactions.edges" in x])[2:-2]
			
			with open(edge_file, "r") as cyto_graph:
				translated_graph = translate_info(translator_dict, cyto_graph)
			

			'''
			Generate the final file
			'''
			complete_info = compile_info(path_info_dict,translated_graph)
			print("Check the psamm folder for the reactions_edges_cytoscape_kegg.tsv")
	except:
		pass


def list_files(path):
	'''
	This function list all info in a path

	:param path: is a path to the folder to be explored
	:return	: all directories and all files separated in diferent variable

	'''

	paths, directories, filenames = next(os.walk(path))
	return(paths, directories, filenames)

def get_target_file(target, dirpath):
    '''
    This function selects an specific file and returns its path
    :param target: is the name
    :param dirpath: is the directory to perform the search
    :return:
    '''
    target_path = "{}/{}".format(dirpath, target[2:-2])
    target_files = list_files(target_path)[2]
    target_compounds = str([x for x in target_files if "compounds" in x])
    target_compounds_path = "{}/{}".format(target_path, target_compounds[2:-2])
    return target_compounds_path

def parse_compounds(file):
    '''
    This functions read a yaml compound file and extract ids and names to be converted
    :param file: a yaml compound file
    :return: a dict
        key: is the name of compound
        value: is the id of compound
    '''

    all_ids = []
    for line in file:
        if line.startswith("- id:"):
        	id_info = line.strip().split()[-1]
        	all_ids.append(id_info)

    return(all_ids)
          
def get_target_model(organism):
	'''
	This function uses bioservices to define a target model

	:param organism: is a str using bigg name for the organism
	:return: the name of BIGG model
	'''
	bigg = BiGG()
	avaliable_models = bigg.search(organism, "models")
	models = [model for model in avaliable_models]
	all_models = []
	for model in models:
	    reaction_value = model['reaction_count']
	    model_id = model['bigg_id']
	    model_meta_info = (model_id, reaction_value)
	    all_models.append(model_meta_info)
	all_models = dict(all_models)
	target_model= max(all_models, key=all_models.get)
	return target_model


def check_translation_need(compounds_data):
	'''
	This function controls the translation step

	It evaluates if its necessary to run all the api
	request.

	:param compunds_data: is a list with all the compounds in the model
	:return: a binary file <dict> containing the info for the translation step
	'''
	outname = "translator.pickle"
	if os.path.exists(outname):
		print(f"Reading info from {outname}")
	else:
		translated_data = multiprocess_engine(compounds_data)
		save_to_binary(translated_data)
	return outname


def translator(compound):
	'''
	This function is the core of the translation

	It uses bioservices to convert BIGG to KEGG ids

	:param compounds: is a list of compounds found in the model
	:return: a dict k: BIGG id, v: KEGG id
	'''
	bigg = BiGG()
	t_info = {}
	organism_target = argv[1]
	organism_target = " ".join(map(str, organism_target.split("_")))
	target_model = get_target_model(organism_target)
	try:
		metabolite_metadata = bigg.metabolites(model_id=target_model, ids=compound)
		KEGG_id = (metabolite_metadata["database_links"]["KEGG Compound"][0]["id"])
	except:
		KEGG_id = compound
	t_info[compound]= KEGG_id
	return t_info		

def multiprocess_engine(compounds_data):
	'''
	This function uses max cpu power to request the database

	It uses multiprocessing to speedup the process of translation
	Obs: to reduce power just specify the number of core to use
	inside Pool(<int>)

	:compounds_data: is a list of compounds
	:return:a full dict k: BIGG id, v: KEGG id

	'''
	p = Pool()

	result = p.map(translator, compounds_data)
	translator_data = dict(ChainMap(*result))

	p.close()
	p.join()
	return(translator_data)


def save_to_binary(data_dict):
	'''
	This function stores a variable to a pickle binary

	Avoid to run a demanding process many times.

	:data_dict: is a dictionary generated by the translation module
	'''
	with open("translator.pickle", "wb") as handle:
		pickle.dump(data_dict, handle, protocol=pickle.HIGHEST_PROTOCOL)

def translate_info(info_dict, file):
	'''
	This function generates a list of list containg cytoscape info

	The information contains souce, target, direction, penwidth and style

	:param info_dict: is a dictionary that contains the BIGG id and the KEGG id 
	:param file: is a tsv file generated by the main tool
	:return: a list containing souce, target, direction, penwidth and style with 
	the translated info
	'''
	new_graph_metadata = []
	for index, line in enumerate(file):
		if index >=1:
			source = line.strip().split('\t')[0]
			source = source.replace("[c]","").replace("[p]","").replace("[e]","")
			translated_source = make_translation(source,info_dict)
			target = line.strip().split('\t')[1]
			target = target.replace("[c]","").replace("[p]","").replace("[e]","")
			translated_target = make_translation(target,info_dict)
			direction = line.strip().split('\t')[2]
			penwidth = line.strip().split('\t')[3]
			style = line.strip().split('\t')[4]
			meta_info = [translated_source, translated_target, direction, penwidth, style]
			new_graph_metadata.append(meta_info)
	return new_graph_metadata
			


def make_translation(compound, info_dict):
	'''
	This function is responsable to evaluate the translation 

	:param compound: is a str with the BIGG id
	:param info_dict: is a dictionary that contains the BIGG id and the KEGG id 
	:return : a str with the KEGG id if it exists, or return the id if doesn't.

	'''
	if compound in info_dict.keys():
		new_name = info_dict[compound]
	else:
		new_name = compound
	return new_name


def check_cyto_build(kegg_ids):
	'''
	This function controls the translation step

	It evaluates if its necessary to run all the api
	request.

	:param compunds_data: is a list with all the compounds in the model
	:return: a binary file <dict> containing the info for the translation step
	'''
	outname = "pathway_information.pickle"
	if os.path.exists(outname):
		print(f"Reading path info from {outname} ")
	else:
		path_info = multiprocess_path_request(kegg_ids)
		save_pathway_info(path_info)
		#save_to_binary(translated_data)
	return outname

def multiprocess_path_request(kegg_ids):
	'''
	This function uses max cpu power to request the database

	It uses multiprocessing to speedup the process of pathway
	aquisition
	Obs: to reduce power just specify the number of core to use
	inside Pool(<int>)

	:compounds_data: is a list of kegg ids
	:return:a full dict k: KEGG id, v: pathway info

	'''
	p = Pool()

	result = p.map(request_kegg_path, kegg_ids)
	path_intel = dict(ChainMap(*result))
	

	p.close()
	p.join()
	return(path_intel)

def get_pathway_info(kegg_ids):
	kegg_paths = {}
	for souce in kegg_ids:
		request_kegg_path(souce, kegg_paths)


def request_kegg_path(source):
	'''
	This function uses Kegg api to find info about compoud pathway


	:param source: str, KEGG id
	:return: A list o pathway description
	'''

	kegg_paths = {}
	s = KEGG()
	kegg_info = s.get("cpd:{}".format(source))
	kegg_info = str(kegg_info)
	if "PATHWAY" in kegg_info:
		path_info = list(filter(None, kegg_info.lstrip().split("PATHWAY")[1].split("MODULE")[0].split("Metabolic pathways")[0].split("DBLINKS")[0].split("ENZYME ")[0].split("\n")))
		path_info = [x.strip() for x in path_info]
	else:
		path_info = "NONE"
	kegg_paths[source] = path_info
	return kegg_paths


def save_pathway_info(data_dict):
	'''
	This function stores a variable to a pickle binary

	Avoid to run a demanding process many times.

	:data_dict: is the data + the path info
	'''
	with open("pathway_information.pickle", "wb") as handle:
		pickle.dump(data_dict, handle, protocol=pickle.HIGHEST_PROTOCOL)

def compile_info(paths_info, graph_info):
	'''
	This function creates a tsv file for cytoscape

	The file contain souce, target, direction, penwidth, style, source and target pathwat info

	:param paths_info: is a dict k: is the kegg id v: is the path description
	:param graph_info: is a list with complete info in the csv file, that will be updated

	'''
	out_name = "reactions_edges_cytoscape_kegg.tsv"
	if os.path.exists(out_name):
		print(f"{out_name} already exists")
	else:
		with open(out_name, "w") as f:
			with redirect_stdout(f):
				print("source\ttarget\tdir\tpenwidth\tstyle\tpath_source\tpath_target")
				for edge in graph_info:
					source = edge[0]
					target = edge[1]
					direction = edge[2]
					penwidth = edge[3]
					style = edge[4]
					if source in paths_info.keys():
						source_path = paths_info[source]
						if source_path != "NONE":
							source_path = ", ".join(map(str, source_path))
					if target in paths_info.keys():
						target_path = paths_info[target]
						if target_path != "NONE":
							target_path = ", ".join(map(str, target_path))
					if source not in paths_info.keys():
						source_path = "No souce info"
					if target not in paths_info.keys():
						target_path = "No target info"
					print("{}\t{}\t{}\t{}\t{}\t{}\t{}".format(source, target, direction, penwidth, style, source_path, target_path))
					




def main():
	try:
		input_data = argv[1]
		if input_data == "-h" or input_data =="--help":
			control(input_data)
		else:
			print("Running translation for {} model organism".format(" ".join(map(str, input_data.split("_")))))
			control(input_data)	
	except:
		print("No input, use -h for help")

	
	

# main
if __name__ == '__main__':
    main()