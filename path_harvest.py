#!/user/bin/env python3

"""
Author: Gustavo Tamasco
Contact: tamascogustavo@gmail.com

"""

# import statements
import os
import pickle
from collections import ChainMap
from contextlib import redirect_stdout
from sys import argv
import json
import urllib.request
import itertools
import requests



#functions and classes


def control():

		'''
		Setting the variable
		'''
		compounds_metadata = {}
		dirpath = os.getcwd()
		

		'''
		Generating info to build the dictionary of metabolites
		'''
		paths, dirs, filenames = list_files(dirpath)
		target = str([x for x in dirs if "psamm" in x])
		target_path = get_target_file(target, dirpath)
		with open(target_path) as compounds_info:
		    compounds_data = parse_compounds(compounds_info)

		'''
		Translation module : translate Bigg ids to kegg ids
		'''
		bigg_universal_link = "http://bigg.ucsd.edu/static/namespace/universal_model.json"
		translator_database = create_translator(bigg_universal_link)
		

		#translator_dict_file = check_translation_need(compounds_data)
		with open(translator_database, "rb") as handle:
			translator_dict = pickle.load(handle)
		
		model_compounds = check_cmp_presence(compounds_data, translator_dict)
		
		all_kegg_ids = [x for x in model_compounds.values() if x.startswith("C0")]
		all_unique_kegg_ids = list(dict.fromkeys(all_kegg_ids))
		
		pathway_info_data = harvest_pathway_info(all_unique_kegg_ids)
		

		with open(pathway_info_data, "rb") as pth_handle:
			path_info_dict_data = pickle.load(pth_handle)
					
		
		'''
		Translate citoscape files

		'''
		graph_dir = str([x for x in dirs if "psamm" in x])[2:-2]
		graph_path = f"{dirpath}/{graph_dir}"
		os.chdir(graph_path)
		edge_file = str([x for x in list_files(graph_path)[2] if "reactions.edges" in x])[2:-2]
		
		
		with open(edge_file, "r") as cyto_graph:
			translated_graph = translate_info(model_compounds, cyto_graph)
		
		
		'''
		Generate the final file
		'''
		complete_info = compile_info(path_info_dict_data,translated_graph)
		print("Check the psamm folder for the reactions_edges_cytoscape_kegg.tsv")
	


def list_files(path):
	'''
	This function list all info in a path

	:param path: is a path to the folder to be explored
	:return	: all directories and all files separated in diferent variable

	'''

	paths, directories, filenames = next(os.walk(path))
	return(paths, directories, filenames)

def get_target_file(target, dirpath):
    '''
    This function selects an specific file and returns its path
    :param target: is the name
    :param dirpath: is the directory to perform the search
    :return:
    '''
    target_path = "{}/{}".format(dirpath, target[2:-2])
    target_files = list_files(target_path)[2]
    target_compounds = str([x for x in target_files if "compounds" in x])
    target_compounds_path = "{}/{}".format(target_path, target_compounds[2:-2])
    return target_compounds_path

def parse_compounds(file):
    '''
    This functions read a yaml compound file and extract ids and names to be converted
    :param file: a yaml compound file
    :return: a dict
        key: is the name of compound
        value: is the id of compound
    '''

    all_ids = []
    for line in file:
        if line.startswith("- id:"):
        	id_info = line.strip().split()[-1]
        	all_ids.append(id_info)

    return(all_ids)
          
def get_target_model(organism):
	'''
	This function uses bioservices to define a target model

	:param organism: is a str using bigg name for the organism
	:return: the name of BIGG model
	'''
	bigg = BiGG()
	avaliable_models = bigg.search(organism, "models")
	models = [model for model in avaliable_models]
	all_models = []
	for model in models:
	    reaction_value = model['reaction_count']
	    model_id = model['bigg_id']
	    model_meta_info = (model_id, reaction_value)
	    all_models.append(model_meta_info)
	all_models = dict(all_models)
	target_model= max(all_models, key=all_models.get)
	return target_model



def create_translator(link):
	'''
	This function parse a bigg universal model to create a translator dict

	:param link: is a str -> link for the model
	:return: the name of a pickle file --> a dict -> k = kegg_id, v = list of bigg ids

	'''
	out_name = "translator.pickle"
	if os.path.exists(out_name):
		print("Translator already exists")
	else:
		data = json.load(urllib.request.urlopen(link))
		compounds = data["metabolites"]

		all_compounds = {}
		for compound in compounds:
		    try:
		        annot = compound["annotation"]
		        kegg_id = str([x for x in annot if 'KEGG Compound' in x ][-1][-1]).split("/")[-1]
		        bigg_ids = compound["notes"]['original_bigg_ids']
		        all_compounds[kegg_id] = bigg_ids
		    except:
		        pass
		save_to_binary(all_compounds)
		print(f"{out_name} was created in your current folder")
	return out_name


def save_to_binary(data_dict):
	'''
	This function stores a variable to a pickle binary

	Avoid to run a demanding process many times.

	:data_dict: is a dictionary generated by the translation module
	'''
	with open("translator.pickle", "wb") as handle:
		pickle.dump(data_dict, handle, protocol=pickle.HIGHEST_PROTOCOL)
		
def check_cmp_presence(model_cpd, translator_db):

	'''
	This function translates metabolides id to kegg ids

	:param model_cpd: is a list of all compounds found in the target model
	:param translator_db: is a dict k: is a str of kegg_id v: is a list of bigg_ids
	:return all_matches: is a dict, k: are the bigg_id in the model v: is the kegg_id
	'''
	
	all_matches = {}
	for cpd in model_cpd:
		pattern = cpd[0:-2]
		for kegg_name, cpds_list in translator_db.items():
			if pattern in cpds_list:
				all_matches[cpd] = kegg_name
	return all_matches

		
		
def harvest_pathway_info(model_compounds_info):
	'''
	This function creates a pathway info database

	:param model_compounds_info: is a list of all compounds in the model
	:return outname: is a binary file, when decompressed is a dict --> k: kegg_id v: is all associated pathways

	'''
	outname = "pathway_information.pickle"
	compound_link = "http://rest.kegg.jp/get/"
	kegg_paths = {}
	outname = "pathway_information.pickle"
	if os.path.exists(outname):
		print(f"Path info already exists. Reading info from {outname}")
	else:
		for vox in model_compounds_info:
			final_link = f"{compound_link}{vox}"
			cpd_path_info = urllib.request.urlopen(final_link)
			path_content = cpd_path_info.read().decode('utf-8')
			parse_path_info(path_content, kegg_paths, vox)
		save_pathway_info(kegg_paths)
		print(f"{outname} was created")
	return outname

		
		
def parse_path_info(path_content, kegg_paths, target):
	'''
	This function extract pathway info from kegg API object

	:param path_content: kegg api object
	:param kegg_paths: dict to store the information on paths
		k: str kegg_id v: list pathway info
	'''
	if "PATHWAY" in path_content:
		path_info = list(filter(None, path_content.lstrip().split("PATHWAY")[1].split("MODULE")[0].split("Metabolic pathways")[0].split("DBLINKS")[0].split("ENZYME ")[0].split("\n")))
		path_info = [x.strip() for x in path_info]
		kegg_paths[target] = path_info
	else:
		path_info = "NONE"
		kegg_paths[target] = path_info


def save_pathway_info(data_dict):
	'''
	This function stores a variable to a pickle binary

	Avoid to run a demanding process many times.

	:data_dict: is the data + the path info
	'''
	with open("pathway_information.pickle", "wb") as handle:
		pickle.dump(data_dict, handle, protocol=pickle.HIGHEST_PROTOCOL)
		


def translate_info(info_dict, file):
	'''
	This function generates a list of list containg cytoscape info

	The information contains souce, target, direction, penwidth and style

	:param info_dict: is a dictionary that contains the BIGG id and the KEGG id 
	:param file: is a tsv file generated by the main tool
	:return: a list containing souce, target, direction, penwidth and style with 
	the translated info
	'''
	new_graph_metadata = []
	for index, line in enumerate(file):
		if index >=1:
			source = line.strip().split('\t')[0]
			source = source.replace("[c]","").replace("[p]","").replace("[e]","")
			translated_source = make_translation(source,info_dict)
			target = line.strip().split('\t')[1]
			target = target.replace("[c]","").replace("[p]","").replace("[e]","")
			translated_target = make_translation(target,info_dict)
			direction = line.strip().split('\t')[2]
			penwidth = line.strip().split('\t')[3]
			style = line.strip().split('\t')[4]
			meta_info = [translated_source, translated_target, direction, penwidth, style]
			new_graph_metadata.append(meta_info)
	return new_graph_metadata
			
				
def make_translation(compound, info_dict):
	'''
	This function is responsable to evaluate the translation 

	:param compound: is a str with the BIGG id
	:param info_dict: is a dictionary that contains the BIGG id and the KEGG id 
	:return : a str with the KEGG id if it exists, or return the id if doesn't.

	'''
	if compound in info_dict.keys():
		new_name = info_dict[compound]
	else:
		new_name = compound
	return new_name
			
def compile_info(paths_info, graph_info):
	'''
	This function creates a tsv file for cytoscape

	The file contain souce, target, direction, penwidth, style, source and target pathwat info

	:param paths_info: is a dict k: is the kegg id v: is the path description
	:param graph_info: is a list with complete info in the csv file, that will be updated

	'''
	out_name = "reactions_edges_cytoscape_kegg.tsv"
	if os.path.exists(out_name):
		print(f"{out_name} already exists")
	else:
		with open(out_name, "w") as f:
			with redirect_stdout(f):
				print("source\ttarget\tdir\tpenwidth\tstyle\tpath_source\tpath_target")
				for edge in graph_info:
					source = edge[0]
					target = edge[1]
					direction = edge[2]
					penwidth = edge[3]
					style = edge[4]
					if source in paths_info.keys():
						source_path = paths_info[source]
						if source_path != "NONE":
							source_path = ", ".join(map(str, source_path))
					if target in paths_info.keys():
						target_path = paths_info[target]
						if target_path != "NONE":
							target_path = ", ".join(map(str, target_path))
					if source not in paths_info.keys():
						source_path = "No souce info"
					if target not in paths_info.keys():
						target_path = "No target info"
					print("{}\t{}\t{}\t{}\t{}\t{}\t{}".format(source, target, direction, penwidth, style, source_path, target_path))
					




			




def main():
	
	print("Running translation for model organism")
	control()	


	
	

# main
if __name__ == '__main__':
    main()